{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"VAMPIRES Data Processing Pipeline \u00b6 Warning: Experimental vampires_dpp is still under development, and the API can change without notice. Use with your own caution (and consider contributing). Primary maintainer: Miles Lucas VAMPIRES data processing tools. First time here? Take a look at the tutorials - TODO Installation \u00b6 For now, install directly from GitHub pip install git+https://github.com/scexao-org/vampires_dpp#egg=vampires_dpp otherwise clone this repository and install locally git clone https://github.com/scexao-org/vampires_dpp pip install vampires_dpp Citing \u00b6 If you use vampires_dpp in your research, please consider citing it as software with the following DOI: TODO License \u00b6 vampires_dpp is licensed under the MIT open-source license. See LICENSE for more details. Contributing and Support \u00b6 If you would like to contribute, feel free to open a pull request . If you want to discuss something before contributing, head over to discussions and join or open a new topic. If you're having problems with something, please open an issue .","title":"Home"},{"location":"#vampires-data-processing-pipeline","text":"Warning: Experimental vampires_dpp is still under development, and the API can change without notice. Use with your own caution (and consider contributing). Primary maintainer: Miles Lucas VAMPIRES data processing tools. First time here? Take a look at the tutorials - TODO","title":"VAMPIRES Data Processing Pipeline"},{"location":"#installation","text":"For now, install directly from GitHub pip install git+https://github.com/scexao-org/vampires_dpp#egg=vampires_dpp otherwise clone this repository and install locally git clone https://github.com/scexao-org/vampires_dpp pip install vampires_dpp","title":"Installation"},{"location":"#citing","text":"If you use vampires_dpp in your research, please consider citing it as software with the following DOI: TODO","title":"Citing"},{"location":"#license","text":"vampires_dpp is licensed under the MIT open-source license. See LICENSE for more details.","title":"License"},{"location":"#contributing-and-support","text":"If you would like to contribute, feel free to open a pull request . If you want to discuss something before contributing, head over to discussions and join or open a new topic. If you're having problems with something, please open an issue .","title":"Contributing and Support"},{"location":"api/","text":"API/Reference \u00b6 Data Organization \u00b6 Calibration \u00b6 calibrate(data, discard=0, dark=None, flat=None, flip=False) \u00b6 Basic frame calibration. Will optionally do dark subtraction, flat correction, discard leading frames, and flip the axes for mirrored data. Parameters: Name Type Description Default data ArrayLike 3-D cube (t, y, x) of data required discard int , optional The amount of leading frames to discard (for data which has destructive readout frames), by default 0 0 dark ArrayLike , optional If provided, will dark-subtract all frames by the provided 2-D master dark (y, x), by default None None flat ArrayLike , optional If provided, will flat-correct (after dark-subtraction) all frames by the provided 2-D master flat (y, x), by default None None flip bool , optional If True, will flip the x-axis of the data, for de-mirroring cam2 data, by default False False Returns: Type Description ArrayLike 3-D calibrated data cube (t, y, x) Source code in vampires_dpp/calibration.py def calibrate( data: ArrayLike, discard: int = 0, dark: Optional[ArrayLike] = None, flat: Optional[ArrayLike] = None, flip: bool = False, ): \"\"\" Basic frame calibration. Will optionally do dark subtraction, flat correction, discard leading frames, and flip the axes for mirrored data. Parameters ---------- data : ArrayLike 3-D cube (t, y, x) of data discard : int, optional The amount of leading frames to discard (for data which has destructive readout frames), by default 0 dark : ArrayLike, optional If provided, will dark-subtract all frames by the provided 2-D master dark (y, x), by default None flat : ArrayLike, optional If provided, will flat-correct (after dark-subtraction) all frames by the provided 2-D master flat (y, x), by default None flip : bool, optional If True, will flip the x-axis of the data, for de-mirroring cam2 data, by default False Returns ------- ArrayLike 3-D calibrated data cube (t, y, x) \"\"\" # discard frames out = data.copy()[discard:] if dark is not None: out = out - dark if flat is not None: out = out / flat if flip: out = np.flip(out, axis=-2) return out deinterleave(data) \u00b6 Deinterleave data into two seperate FLC states Parameters: Name Type Description Default data ArrayLike 3-D data cube (t, y, x) from a single camera required Returns: Type Description state1 , state2 two 3-D data cubes (t, y, x), one for every other frame from the original cube Source code in vampires_dpp/calibration.py def deinterleave(data: ArrayLike): \"\"\" Deinterleave data into two seperate FLC states Parameters ---------- data : ArrayLike 3-D data cube (t, y, x) from a single camera Returns ------- (state1, state2) : Tuple[ArrayLike, ArrayLike] two 3-D data cubes (t, y, x), one for every other frame from the original cube \"\"\" set1 = data[::2] set2 = data[1::2] return set1, set2 Image Processing \u00b6 frame_center(image) \u00b6 Find the center of the frame or cube in pixel coordinates Parameters: Name Type Description Default image ArrayLike N-D array with the final two dimensions as the (y, x) axes. required Returns: Type Description cy , cx A tuple of the image center in pixel coordinates Source code in vampires_dpp/image_processing.py def frame_center(image: ArrayLike): \"\"\" Find the center of the frame or cube in pixel coordinates Parameters ---------- image : ArrayLike N-D array with the final two dimensions as the (y, x) axes. Returns ------- (cy, cx) A tuple of the image center in pixel coordinates \"\"\" ny = image.shape[-2] nx = image.shape[-1] return (ny - 1) / 2, (nx - 1) / 2 Satellite Spots \u00b6 window_masks(frame, **kwargs) \u00b6 Get a boolean mask for the satellite spots Parameters: Name Type Description Default frame ArrayLike image frame required **kwargs Extra keyword arguments are passed to window_indices {} Returns: Name Type Description mask ArrayLike boolean mask where True indicates inclusion in satellite spot window Source code in vampires_dpp/satellite_spots.py def window_masks(frame, **kwargs): \"\"\" Get a boolean mask for the satellite spots Parameters ---------- frame : ArrayLike image frame **kwargs Extra keyword arguments are passed to `window_indices` Returns ------- mask : ArrayLike boolean mask where True indicates inclusion in satellite spot window \"\"\" inds = window_indices(frame, **kwargs) out = np.zeros(frame.size, dtype=bool) for ind in inds: out[ind] = True return np.reshape(out, frame.shape) window_indices(frame, window=30, center=None, **kwargs) \u00b6 Get the linear indices for each satellite spot Parameters: Name Type Description Default frame ArrayLike image frame required window float , Tuple , optional window size, or tuple for each axis, by default 30 30 center Tuple , optional (y, x) coordinate of cross center, by default None, which defaults to the frame center. None **kwargs Extra keyword arguments are passed to window_centers {} Returns: Type Description list List of linear indices for each spot Source code in vampires_dpp/satellite_spots.py def window_indices(frame, window=30, center=None, **kwargs): \"\"\" Get the linear indices for each satellite spot Parameters ---------- frame : ArrayLike image frame window : float, Tuple, optional window size, or tuple for each axis, by default 30 center : Tuple, optional (y, x) coordinate of cross center, by default None, which defaults to the frame center. **kwargs Extra keyword arguments are passed to `window_centers` Returns ------- list List of linear indices for each spot \"\"\" if center is None: center = frame_center(frame) centers = window_centers(center, **kwargs) slices = [window_slice(frame, center=cent, window=window) for cent in centers] coords = [cart_coords(sl[0], sl[1]) for sl in slices] inds = [ np.ravel_multi_index((coord[:, 0], coord[:, 1]), frame.shape) for coord in coords ] return inds window_centers(center, radius, theta=0, n=4) \u00b6 Get the centers (y, x) for each point radius away from center along n branches starting theta degrees CCW from the x-axis Parameters: Name Type Description Default center Tuple cross center (y, x) required radius float radius of the spot separation, in pixels required theta float , optional Offset the branches by the given number of degrees CCW from the x-axis, by default 0 0 n int , optional the number of branches, by default 4 4 Returns: Type Description centers list of centers (y, x) for each spot Source code in vampires_dpp/satellite_spots.py def window_centers(center, radius, theta=0, n=4): \"\"\" Get the centers (y, x) for each point `radius` away from `center` along `n` branches starting `theta` degrees CCW from the x-axis Parameters ---------- center : Tuple cross center (y, x) radius : float radius of the spot separation, in pixels theta : float, optional Offset the branches by the given number of degrees CCW from the x-axis, by default 0 n : int, optional the number of branches, by default 4 Returns ------- centers list of centers (y, x) for each spot \"\"\" # get the angles for each branch theta = np.linspace(0, 2 * np.pi, n, endpoint=False) + np.deg2rad(theta) xs = radius * np.cos(theta) + center[1] ys = radius * np.sin(theta) + center[0] return list(zip(ys, xs)) Lucky Imaging \u00b6","title":"API/Reference"},{"location":"api/#apireference","text":"","title":"API/Reference"},{"location":"api/#data-organization","text":"","title":"Data Organization"},{"location":"api/#calibration","text":"","title":"Calibration"},{"location":"api/#vampires_dpp.calibration.calibrate","text":"Basic frame calibration. Will optionally do dark subtraction, flat correction, discard leading frames, and flip the axes for mirrored data. Parameters: Name Type Description Default data ArrayLike 3-D cube (t, y, x) of data required discard int , optional The amount of leading frames to discard (for data which has destructive readout frames), by default 0 0 dark ArrayLike , optional If provided, will dark-subtract all frames by the provided 2-D master dark (y, x), by default None None flat ArrayLike , optional If provided, will flat-correct (after dark-subtraction) all frames by the provided 2-D master flat (y, x), by default None None flip bool , optional If True, will flip the x-axis of the data, for de-mirroring cam2 data, by default False False Returns: Type Description ArrayLike 3-D calibrated data cube (t, y, x) Source code in vampires_dpp/calibration.py def calibrate( data: ArrayLike, discard: int = 0, dark: Optional[ArrayLike] = None, flat: Optional[ArrayLike] = None, flip: bool = False, ): \"\"\" Basic frame calibration. Will optionally do dark subtraction, flat correction, discard leading frames, and flip the axes for mirrored data. Parameters ---------- data : ArrayLike 3-D cube (t, y, x) of data discard : int, optional The amount of leading frames to discard (for data which has destructive readout frames), by default 0 dark : ArrayLike, optional If provided, will dark-subtract all frames by the provided 2-D master dark (y, x), by default None flat : ArrayLike, optional If provided, will flat-correct (after dark-subtraction) all frames by the provided 2-D master flat (y, x), by default None flip : bool, optional If True, will flip the x-axis of the data, for de-mirroring cam2 data, by default False Returns ------- ArrayLike 3-D calibrated data cube (t, y, x) \"\"\" # discard frames out = data.copy()[discard:] if dark is not None: out = out - dark if flat is not None: out = out / flat if flip: out = np.flip(out, axis=-2) return out","title":"calibrate()"},{"location":"api/#vampires_dpp.calibration.deinterleave","text":"Deinterleave data into two seperate FLC states Parameters: Name Type Description Default data ArrayLike 3-D data cube (t, y, x) from a single camera required Returns: Type Description state1 , state2 two 3-D data cubes (t, y, x), one for every other frame from the original cube Source code in vampires_dpp/calibration.py def deinterleave(data: ArrayLike): \"\"\" Deinterleave data into two seperate FLC states Parameters ---------- data : ArrayLike 3-D data cube (t, y, x) from a single camera Returns ------- (state1, state2) : Tuple[ArrayLike, ArrayLike] two 3-D data cubes (t, y, x), one for every other frame from the original cube \"\"\" set1 = data[::2] set2 = data[1::2] return set1, set2","title":"deinterleave()"},{"location":"api/#image-processing","text":"","title":"Image Processing"},{"location":"api/#vampires_dpp.image_processing.frame_center","text":"Find the center of the frame or cube in pixel coordinates Parameters: Name Type Description Default image ArrayLike N-D array with the final two dimensions as the (y, x) axes. required Returns: Type Description cy , cx A tuple of the image center in pixel coordinates Source code in vampires_dpp/image_processing.py def frame_center(image: ArrayLike): \"\"\" Find the center of the frame or cube in pixel coordinates Parameters ---------- image : ArrayLike N-D array with the final two dimensions as the (y, x) axes. Returns ------- (cy, cx) A tuple of the image center in pixel coordinates \"\"\" ny = image.shape[-2] nx = image.shape[-1] return (ny - 1) / 2, (nx - 1) / 2","title":"frame_center()"},{"location":"api/#satellite-spots","text":"","title":"Satellite Spots"},{"location":"api/#vampires_dpp.satellite_spots.window_masks","text":"Get a boolean mask for the satellite spots Parameters: Name Type Description Default frame ArrayLike image frame required **kwargs Extra keyword arguments are passed to window_indices {} Returns: Name Type Description mask ArrayLike boolean mask where True indicates inclusion in satellite spot window Source code in vampires_dpp/satellite_spots.py def window_masks(frame, **kwargs): \"\"\" Get a boolean mask for the satellite spots Parameters ---------- frame : ArrayLike image frame **kwargs Extra keyword arguments are passed to `window_indices` Returns ------- mask : ArrayLike boolean mask where True indicates inclusion in satellite spot window \"\"\" inds = window_indices(frame, **kwargs) out = np.zeros(frame.size, dtype=bool) for ind in inds: out[ind] = True return np.reshape(out, frame.shape)","title":"window_masks()"},{"location":"api/#vampires_dpp.satellite_spots.window_indices","text":"Get the linear indices for each satellite spot Parameters: Name Type Description Default frame ArrayLike image frame required window float , Tuple , optional window size, or tuple for each axis, by default 30 30 center Tuple , optional (y, x) coordinate of cross center, by default None, which defaults to the frame center. None **kwargs Extra keyword arguments are passed to window_centers {} Returns: Type Description list List of linear indices for each spot Source code in vampires_dpp/satellite_spots.py def window_indices(frame, window=30, center=None, **kwargs): \"\"\" Get the linear indices for each satellite spot Parameters ---------- frame : ArrayLike image frame window : float, Tuple, optional window size, or tuple for each axis, by default 30 center : Tuple, optional (y, x) coordinate of cross center, by default None, which defaults to the frame center. **kwargs Extra keyword arguments are passed to `window_centers` Returns ------- list List of linear indices for each spot \"\"\" if center is None: center = frame_center(frame) centers = window_centers(center, **kwargs) slices = [window_slice(frame, center=cent, window=window) for cent in centers] coords = [cart_coords(sl[0], sl[1]) for sl in slices] inds = [ np.ravel_multi_index((coord[:, 0], coord[:, 1]), frame.shape) for coord in coords ] return inds","title":"window_indices()"},{"location":"api/#vampires_dpp.satellite_spots.window_centers","text":"Get the centers (y, x) for each point radius away from center along n branches starting theta degrees CCW from the x-axis Parameters: Name Type Description Default center Tuple cross center (y, x) required radius float radius of the spot separation, in pixels required theta float , optional Offset the branches by the given number of degrees CCW from the x-axis, by default 0 0 n int , optional the number of branches, by default 4 4 Returns: Type Description centers list of centers (y, x) for each spot Source code in vampires_dpp/satellite_spots.py def window_centers(center, radius, theta=0, n=4): \"\"\" Get the centers (y, x) for each point `radius` away from `center` along `n` branches starting `theta` degrees CCW from the x-axis Parameters ---------- center : Tuple cross center (y, x) radius : float radius of the spot separation, in pixels theta : float, optional Offset the branches by the given number of degrees CCW from the x-axis, by default 0 n : int, optional the number of branches, by default 4 Returns ------- centers list of centers (y, x) for each spot \"\"\" # get the angles for each branch theta = np.linspace(0, 2 * np.pi, n, endpoint=False) + np.deg2rad(theta) xs = radius * np.cos(theta) + center[1] ys = radius * np.sin(theta) + center[0] return list(zip(ys, xs))","title":"window_centers()"},{"location":"api/#lucky-imaging","text":"","title":"Lucky Imaging"},{"location":"gettingstarted/","text":"Getting started \u00b6 VAMPIRES Observation Modes \u00b6 VAMPIRES is an incredibly diverse instrument in its usage with SCExAO. It can be used for studying evolved stellar physics, protoplanetary disks, polarimetry, H-\u0251 emission, in addition to an interferometric mode via sparse aperture masking (SAM). VAMPIRES is also used for focal-plane wavefront sensing, for example using differential focus for phase diversity , as well as complementary data for infrared observations (i.e., telemetry). vampires_dpp provides tooling primarily for imaging modes, although the image-processing tools provide building blocks for a variety of applications of VAMPIRES data (and PRs are welcome for interferometric modes!). The following observation modes have well-defined tutorials and workflows, and represent the majority of open-use observations Speckle imaging / telemetry (TODO) Polarimetric differential imaging (TODO) Coronagraphic polarimetric differential imaging (TODO) H-\u0251 differential imaging (TODO) VAMPIRES Data Formats \u00b6 Depending on who you are, you may have to deal with a variety of VAMPIRES data formats. For open-use observers, this is the STARS gen-2 archive format, which is different from the format saved by VAMPIRES during acquisition, and is different from internal telemetry stream data. The vampires_dpp prioritizes the gen-2 format highest, but the API should be flexible enough to accommadate any user of VAMPIRES- observer or engineer. Conventions \u00b6 The data follow these general specifications Parallactic angles are specified as degrees CCW from the North-celestial pole Image coordinates follow python conventions The bottom-left pixel center has coordinates (0, 0) (DS9 minus one) The natural axes for images in numpy arrays are (y, x) (transpose/reverse of DS9) The image center is therefore (ny - 1) / 2, (nx - 1) / 2 Camera 1 is flipped on its y-axis compared to sky The beam-splitter will naturally mirror the beam along this axis so camera 2 doesn't need flipped Formats for imaging and PDI modes \u00b6 Gen-2 archive format ( default for open-use observers ) Files are given frame id names, e.g. \"VMPA0023445.fits\" Each file corresponds to a single camera, FLC state, and HWP angle Rich FITS headers VAMPIRES format Files have names as set by controller, e.g. \"HD141569A_00_750-50_LyotStop_00_cam1.fits\" Each file is a raw cube from the camera, which includes bad readout frame in the first frame FLC states interleaved in every other frame for PDI mode Rich FITS headers Stream format Files are given stream names, e.g. \"vcamim1_12:04:34.234412598.fits\" Camera 1 and 2 may or may not be synced, depending on observer usage No meaningful metadata present in the FITS headers (e.g., gain, HWP, camera, etc.) Extremely precise frame-grabber timing Note: Multiple HDU FITS files Some old VAMPIRES data (circa 2019 and earlier) had multiple FITS header data units (HDUs) to store header information. vampires_dpp is not built to support these data, but a conversion script could be written if requested. Processing Workflows \u00b6 vampires_dpp is built with multiple processing workflows in mind to support the large diversity of observing modes and usages of VAMPIRES. Typical VAMPIRES observations produce many gigabytes of data across hundreds of files, which means processing data must occur on a file-by-file basis, with the potential for multi-processing. A large portion of the vampires_dpp API is available in a command line interface (CLI) for quick processing of files and various other helpers. Despite the attractive ease of using the scripting interface, if you plan to publish or share the data you have reduced, please consider saving your commands in bash scripts or using the python interface and a python script so that your reductions can be shared with and reproduced by future investigators. As alluded to above, the most direct interface with the API is, well, the Python API itself! Any script you find will be composed of functions in the vampires_dpp python module, which gets installed when you pip install this code. If you are someone who likes working in Jupyter notebooks, or in interactive scripting environments like iPython, this will give you not only the most direct access to the API, but will allow you to customize your process however you please. The python methods even include the same progress bars and file-by-file processing of the command line tools! Getting Help \u00b6 Hopefully the tutorials we provide give enough explanation for the common use-cases of VAMPIRES, but if you ran into issues or have suggestions please let us know in the issues . If you have more complicated questions or data issues contact the SCExAO team directly (c.c. Barnaby Norris and Miles Lucas ).","title":"Getting Started"},{"location":"gettingstarted/#getting-started","text":"","title":"Getting started"},{"location":"gettingstarted/#vampires-observation-modes","text":"VAMPIRES is an incredibly diverse instrument in its usage with SCExAO. It can be used for studying evolved stellar physics, protoplanetary disks, polarimetry, H-\u0251 emission, in addition to an interferometric mode via sparse aperture masking (SAM). VAMPIRES is also used for focal-plane wavefront sensing, for example using differential focus for phase diversity , as well as complementary data for infrared observations (i.e., telemetry). vampires_dpp provides tooling primarily for imaging modes, although the image-processing tools provide building blocks for a variety of applications of VAMPIRES data (and PRs are welcome for interferometric modes!). The following observation modes have well-defined tutorials and workflows, and represent the majority of open-use observations Speckle imaging / telemetry (TODO) Polarimetric differential imaging (TODO) Coronagraphic polarimetric differential imaging (TODO) H-\u0251 differential imaging (TODO)","title":"VAMPIRES Observation Modes"},{"location":"gettingstarted/#vampires-data-formats","text":"Depending on who you are, you may have to deal with a variety of VAMPIRES data formats. For open-use observers, this is the STARS gen-2 archive format, which is different from the format saved by VAMPIRES during acquisition, and is different from internal telemetry stream data. The vampires_dpp prioritizes the gen-2 format highest, but the API should be flexible enough to accommadate any user of VAMPIRES- observer or engineer.","title":"VAMPIRES Data Formats"},{"location":"gettingstarted/#conventions","text":"The data follow these general specifications Parallactic angles are specified as degrees CCW from the North-celestial pole Image coordinates follow python conventions The bottom-left pixel center has coordinates (0, 0) (DS9 minus one) The natural axes for images in numpy arrays are (y, x) (transpose/reverse of DS9) The image center is therefore (ny - 1) / 2, (nx - 1) / 2 Camera 1 is flipped on its y-axis compared to sky The beam-splitter will naturally mirror the beam along this axis so camera 2 doesn't need flipped","title":"Conventions"},{"location":"gettingstarted/#formats-for-imaging-and-pdi-modes","text":"Gen-2 archive format ( default for open-use observers ) Files are given frame id names, e.g. \"VMPA0023445.fits\" Each file corresponds to a single camera, FLC state, and HWP angle Rich FITS headers VAMPIRES format Files have names as set by controller, e.g. \"HD141569A_00_750-50_LyotStop_00_cam1.fits\" Each file is a raw cube from the camera, which includes bad readout frame in the first frame FLC states interleaved in every other frame for PDI mode Rich FITS headers Stream format Files are given stream names, e.g. \"vcamim1_12:04:34.234412598.fits\" Camera 1 and 2 may or may not be synced, depending on observer usage No meaningful metadata present in the FITS headers (e.g., gain, HWP, camera, etc.) Extremely precise frame-grabber timing Note: Multiple HDU FITS files Some old VAMPIRES data (circa 2019 and earlier) had multiple FITS header data units (HDUs) to store header information. vampires_dpp is not built to support these data, but a conversion script could be written if requested.","title":"Formats for imaging and PDI modes"},{"location":"gettingstarted/#processing-workflows","text":"vampires_dpp is built with multiple processing workflows in mind to support the large diversity of observing modes and usages of VAMPIRES. Typical VAMPIRES observations produce many gigabytes of data across hundreds of files, which means processing data must occur on a file-by-file basis, with the potential for multi-processing. A large portion of the vampires_dpp API is available in a command line interface (CLI) for quick processing of files and various other helpers. Despite the attractive ease of using the scripting interface, if you plan to publish or share the data you have reduced, please consider saving your commands in bash scripts or using the python interface and a python script so that your reductions can be shared with and reproduced by future investigators. As alluded to above, the most direct interface with the API is, well, the Python API itself! Any script you find will be composed of functions in the vampires_dpp python module, which gets installed when you pip install this code. If you are someone who likes working in Jupyter notebooks, or in interactive scripting environments like iPython, this will give you not only the most direct access to the API, but will allow you to customize your process however you please. The python methods even include the same progress bars and file-by-file processing of the command line tools!","title":"Processing Workflows"},{"location":"gettingstarted/#getting-help","text":"Hopefully the tutorials we provide give enough explanation for the common use-cases of VAMPIRES, but if you ran into issues or have suggestions please let us know in the issues . If you have more complicated questions or data issues contact the SCExAO team directly (c.c. Barnaby Norris and Miles Lucas ).","title":"Getting Help"},{"location":"tutorials/","text":"Tutorials \u00b6 VAMPIRES is a very dynamic instrument used in a variety of observing scenarios. The tutorials below represent some of the most common use-cases of VAMPIRES, and while open-use observer modes are prioritized there are also tutorials for engineering related tasks. Open-use observing \u00b6 Speckle imaging (TODO) Polarimetric differential imaging (TODO) Engineering \u00b6 Pixel scale and PA offset measurement (TODO) Satellite spot calibration (TODO)","title":"Tutorials"},{"location":"tutorials/#tutorials","text":"VAMPIRES is a very dynamic instrument used in a variety of observing scenarios. The tutorials below represent some of the most common use-cases of VAMPIRES, and while open-use observer modes are prioritized there are also tutorials for engineering related tasks.","title":"Tutorials"},{"location":"tutorials/#open-use-observing","text":"Speckle imaging (TODO) Polarimetric differential imaging (TODO)","title":"Open-use observing"},{"location":"tutorials/#engineering","text":"Pixel scale and PA offset measurement (TODO) Satellite spot calibration (TODO)","title":"Engineering"}]}